const std = @import("std");
const Allocator = std.mem.Allocator;
const ArrayList = std.ArrayList;
const builtin = @import("builtin");
const Writer = std.Io.Writer;

const util = @import("util.zig");
const Node = @import("Node.zig");

allocator: Allocator,
template_paths: []const TemplatePath,
templates_paths: []const TemplatePath,

const Manifest = @This();

pub const TemplatePath = struct {
    prefix: []const u8,
    path: []const u8,
    present: bool,
};

const TemplateDef = struct {
    key: []const u8,
    name: []const u8,
    prefix: []const u8,
    content: []const u8,
    partial: bool,
    blocks: std.StringHashMap(ArrayList(Node.Block)),

    pub fn renderBlocks(template_def: TemplateDef, allocator: Allocator) ![]const u8 {
        var aw: Writer.Allocating = .init(allocator);
        defer aw.deinit();
        var it = template_def.blocks.valueIterator();
        while (it.next()) |blocks| {
            for (blocks.items) |block| {
                try aw.writer.print(
                    \\.{{ .name = "{s}", .func = "{s}" }},
                ,
                    .{ block.name, block.func },
                );
            }
        }
        return aw.toOwnedSlice();
    }
};

pub fn init(
    allocator: Allocator,
    templates_paths: []const TemplatePath,
    template_paths: []const TemplatePath,
) Manifest {
    return .{
        .allocator = allocator,
        .templates_paths = templates_paths,
        .template_paths = template_paths,
    };
}

pub fn compile(
    self: *Manifest,
    comptime TemplateType: type,
    comptime options: type,
) ![]const u8 {
    var template_defs = std.array_list.Managed(TemplateDef).init(self.allocator);

    var templates_paths_map = std.StringHashMap([]const u8).init(self.allocator);
    for (self.templates_paths) |templates_path| {
        try templates_paths_map.put(templates_path.prefix, templates_path.path);
    }

    var template_map = std.StringHashMap(TemplateType.TemplateMap).init(self.allocator);

    // First pass - generate names for all templates and store in prefix->name nested hashmap.
    for (self.template_paths) |template_path| {
        const result = try template_map.getOrPut(template_path.prefix);
        var map = if (result.found_existing)
            result.value_ptr
        else blk: {
            result.value_ptr.* = TemplateType.TemplateMap.init(self.allocator);
            break :blk result.value_ptr;
        };

        const generated_name = try util.generateVariableNameAlloc(self.allocator);
        const key = try util.templatePathStore(
            self.allocator,
            templates_paths_map.get(template_path.prefix).?,
            template_path.path,
        );
        if (map.get(key)) |_| {
            std.debug.print("[zmpl] Found duplicate template: {s}\n", .{template_path.path});
            std.debug.print("[zmpl] Template names must be uniquely identifiable. Exiting.\n", .{});
            std.process.exit(1);
        }

        try map.putNoClobber(key, generated_name);
    }

    // Second pass - compile all templates, some of which may reference templates in other prefix scopes
    for (self.templates_paths) |templates_path| {
        try self.compileTemplates(
            &template_defs,
            templates_path,
            templates_paths_map,
            TemplateType,
            &template_map,
            options,
        );
    }
    std.debug.print("[zmpl] Compiled {} template(s)\n", .{self.template_paths.len});

    var aw: Writer.Allocating = .init(self.allocator);
    defer aw.deinit();

    try aw.writer.writeAll(
        \\// Zmpl template manifest.
        \\// This file is automatically generated at build time and should not be manually modified.
        \\
        \\const std = @import("std");
        \\const __zmpl = @import("zmpl");
        \\
    );

    if (@hasDecl(options, "manifest_header")) {
        const manifest_header = options.manifest_header;
        const decodedHeader: []u8 = try self.allocator.alloc(u8, try std.base64.standard.Decoder.calcSizeForSlice(manifest_header));
        defer self.allocator.free(decodedHeader);
        try std.base64.standard.Decoder.decode(decodedHeader, manifest_header);

        try aw.writer.writeAll(decodedHeader);
    }

    try aw.writer.writeAll(
        \\
        \\pub const ZmplValue = __zmpl.Data.Value;
        \\pub const __Manifest = struct {
    );

    for (template_defs.items) |template_def| {
        try aw.writer.writeAll(try std.fmt.allocPrint(self.allocator,
            \\
            \\{s}
            \\
        , .{template_def.content}));
    }
    for (template_defs.items) |template_def| {
        if (template_def.partial) continue;

        try aw.writer.writeAll(try std.fmt.allocPrint(self.allocator,
            \\const {0s} = __Manifest.Template{{
            \\  .key = "{2s}",
            \\  .name = "{0s}",
            \\  .prefix = "{1s}",
            \\  .blocks = &.{{{3s}}},
            \\}};
            \\
        , .{
            template_def.name,
            template_def.prefix,
            template_def.key,
            try template_def.renderBlocks(self.allocator),
        }));
    }

    try aw.writer.writeAll(
        \\    const TemplateType = enum { zmpl, markdown };
        \\    pub const Template = __zmpl.Template;
        \\    pub const templates = [_]Template{
        \\
    );

    for (template_defs.items) |template_def| {
        if (template_def.partial) continue;

        try aw.writer.print(
            \\{s},
            \\
        ,
            .{template_def.name},
        );
    }

    try aw.writer.writeAll(
        \\};
        \\
        \\
        \\    /// Find any template matching a given name. Uses all template paths in order.
        \\    pub fn find(name: []const u8) ?Template {
        \\        for (templates) |template| {
        \\            if (!std.mem.eql(u8, template.key, name)) continue;
        \\
        \\            return template;
        \\        }
        \\
        \\        return null;
        \\    }
        \\
        \\    /// Find a template in a given prefix, i.e. a template located within a specific
        \\    /// template path.
        \\    pub fn findPrefixed(prefix: []const u8, name: []const u8) ?Template {
        \\        for (templates) |template| {
        \\            if (!std.mem.eql(u8, template.prefix, prefix)) continue;
        \\            if (!std.mem.eql(u8, template.key, name)) continue;
        \\
        \\            return template;
        \\        }
        \\
        \\        return null;
        \\    }
        \\};
    );
    const output = try aw.toOwnedSlice();
    defer self.allocator.free(output);
    return self.allocator.dupe(u8, output);
}

fn compileTemplates(
    self: *Manifest,
    array: *std.array_list.Managed(TemplateDef),
    templates_path: TemplatePath,
    templates_paths_map: std.StringHashMap([]const u8),
    comptime TemplateType: type,
    template_map: *std.StringHashMap(TemplateType.TemplateMap),
    comptime options: type,
) !void {
    for (self.template_paths) |template_path| {
        if (!template_path.present) continue;
        if (!std.mem.eql(u8, template_path.prefix, templates_path.prefix)) continue;

        const key = try util.templatePathStore(self.allocator, templates_paths_map.get(template_path.prefix).?, template_path.path);
        const generated_name = template_map.get(template_path.prefix).?.get(key).?;

        var file = try std.fs.openFileAbsolute(template_path.path, .{});
        const size = (try file.stat()).size;
        var fr = file.reader(&.{});
        const content = try fr.interface.allocRemaining(self.allocator, .limited64(size));
        var template = TemplateType.init(
            self.allocator,
            generated_name,
            templates_path.path,
            templates_path.prefix,
            template_path.path,
            templates_paths_map,
            content,
            template_map.*,
        );
        const partial = template.partial;
        const output = try template.compile(options);

        const template_def: TemplateDef = .{
            .key = key,
            .name = generated_name,
            .prefix = templates_path.prefix,
            .content = output,
            .partial = partial,
            .blocks = template.block_map,
        };

        try array.append(template_def);
    }
}
