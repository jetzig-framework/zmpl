const Manifest = @This();

const std = @import("std");
const Allocator = std.mem.Allocator;
const ArenaAllocator = std.heap.ArenaAllocator;
const ArrayList = std.ArrayList;
const Writer = std.Io.Writer;
const StringHashMap = std.StringHashMapUnmanaged;
const Decoder = std.base64.standard.Decoder;
const builtin = @import("builtin");

const util = @import("util.zig");
const Node = @import("Node.zig");
const Template = @import("Template.zig");

template_paths: []const TemplatePath,
templates_paths: []const TemplatePath,

pub fn init(
    templates_paths: []const TemplatePath,
    template_paths: []const TemplatePath,
) Manifest {
    return .{
        .templates_paths = templates_paths,
        .template_paths = template_paths,
    };
}

pub fn compile(
    self: *Manifest,
    allocator: Allocator,
    writer: *Writer,
    comptime options: type,
) !void {
    try writer.writeAll(
        \\// Zmpl template manifest.
        \\// This file is automatically generated at build time and should not be manually modified.
        \\
        \\const std = @import("std");
        \\const __zmpl = @import("zmpl");
        \\
    );

    if (@hasDecl(options, "manifest_header")) {
        const manifest_header: []const u8 = options.manifest_header;
        const required_size = try Decoder.calcSizeForSlice(manifest_header);
        const decoded_header = try allocator.alloc(u8, required_size);
        defer allocator.free(decoded_header);
        try Decoder.decode(decoded_header, manifest_header);
        try writer.writeAll(decoded_header);
    }

    try writer.writeAll(
        \\
        \\pub const ZmplValue = __zmpl.Data.Value;
        \\pub const __Manifest = struct {
    );

    var template_defs: ArrayList(TemplateDef) = .empty;
    defer template_defs.deinit(allocator);

    var templates_paths_map: StringHashMap([]const u8) = .empty;
    defer templates_paths_map.deinit(allocator);

    for (self.templates_paths) |templates_path|
        try templates_paths_map.put(allocator, templates_path.prefix, templates_path.path);

    var template_map: StringHashMap(Template.TemplateMap) = .empty;
    defer template_map.deinit(allocator);

    // First pass - generate names for all templates and store in prefix->name nested hashmap.
    for (self.template_paths) |template_path| {
        const result = try template_map.getOrPut(allocator, template_path.prefix);
        var map = if (result.found_existing)
            result.value_ptr
        else blk: {
            result.value_ptr.* = Template.TemplateMap.empty;
            break :blk result.value_ptr;
        };

        const generated_name = try util.generateVariableNameAlloc(allocator);
        const key = try util.templatePathStore(
            allocator,
            templates_paths_map.get(template_path.prefix).?,
            template_path.path,
        );
        if (map.get(key)) |_| {
            std.debug.print("[zmpl] Found duplicate template: {s}\n", .{template_path.path});
            std.debug.print("[zmpl] Template names must be uniquely identifiable. Exiting.\n", .{});
            std.process.exit(1);
        }

        try map.putNoClobber(allocator, key, generated_name);
    }

    // Second pass - compile all templates, some of which may reference templates in other prefix scopes
    for (self.templates_paths) |outer_path| {
        // for (self.template_paths) |inner_path| {
        //     if (!inner_path.present) continue;
        //     if (!std.mem.eql(u8, inner_path.prefix, outer_path.prefix)) continue;
        //     const key = try util.templatePathStore(
        //         allocator,
        //         templates_paths_map.get(inner_path.prefix) orelse @panic("wtf"),
        //         inner_path.path,
        //     );
        //     const generated_name = template_map.get(inner_path.prefix).?.get(key).?;
        //     var file = try std.fs.openFileAbsolute(inner_path.path, .{});
        // }
        try self.compileTemplates(
            allocator,
            &template_defs,
            outer_path,
            templates_paths_map,
            &template_map,
            options,
        );
    }
    std.debug.print("[zmpl] Compiled {} template(s)\n", .{self.template_paths.len});
    // placeholder

    for (template_defs.items) |template_def|
        try writer.print(
            \\
            \\{s}
            \\
        , .{template_def.content});
    for (template_defs.items) |template_def| {
        if (template_def.partial) continue;

        try writer.print(
            \\const {[name]s} = __Manifest.Template{{
            \\    .key = "{[key]s}",
            \\    .name = "{[name]s}",
            \\    .prefix = "{[prefix]s}",
            \\    .blocks = &.{{
        , .{
            .name = template_def.name,
            .key = template_def.key,
            .prefix = template_def.prefix,
        });
        try template_def.renderBlocks(writer);
        try writer.writeAll(
            \\},
            \\};
            \\
        );
    }

    try writer.writeAll(
        \\    const TemplateType = enum { zmpl, markdown };
        \\    pub const Template = __zmpl.Template;
        \\    pub const templates = [_]Template{
        \\
    );

    for (template_defs.items) |template_def|
        if (!template_def.partial) try writer.print(
            \\{s},
            \\
        ,
            .{template_def.name},
        );

    try writer.writeAll(
        \\};
        \\
        \\
        \\    /// Find any template matching a given name. Uses all template paths in order.
        \\    pub fn find(name: []const u8) ?Template {
        \\        for (templates) |template| {
        \\            if (!std.mem.eql(u8, template.key, name)) continue;
        \\            return template;
        \\        }
        \\        return null;
        \\    }
        \\
        \\    /// Find a template in a given prefix, i.e. a template located within a specific
        \\    /// template path.
        \\    pub fn findPrefixed(prefix: []const u8, name: []const u8) ?Template {
        \\        for (templates) |template| {
        \\            if (!std.mem.eql(u8, template.prefix, prefix)) continue;
        \\            if (!std.mem.eql(u8, template.key, name)) continue;
        \\            return template;
        \\        }
        \\        return null;
        \\    }
        \\};
    );
}

fn compileTemplates(
    self: *Manifest,
    allocator: Allocator,
    array: *ArrayList(TemplateDef),
    templates_path: TemplatePath,
    templates_paths_map: StringHashMap([]const u8),
    template_map: *StringHashMap(Template.TemplateMap),
    comptime options: type,
) !void {
    for (self.template_paths) |template_path| {
        if (!template_path.present) continue;
        if (!std.mem.eql(u8, template_path.prefix, templates_path.prefix)) continue;

        const key = try util.templatePathStore(allocator, templates_paths_map.get(template_path.prefix).?, template_path.path);
        const generated_name = template_map.get(template_path.prefix).?.get(key).?;

        var file = try std.fs.openFileAbsolute(template_path.path, .{});
        const size = (try file.stat()).size;
        const content = try file.readToEndAlloc(allocator, @intCast(size));
        var template: Template = .init(
            allocator,
            generated_name,
            templates_path.path,
            templates_path.prefix,
            template_path.path,
            templates_paths_map,
            content,
            template_map.*,
        );
        const output = try template.compile(options);

        const template_def: TemplateDef = .{
            .key = key,
            .name = generated_name,
            .prefix = templates_path.prefix,
            .content = output,
            .partial = template.partial,
            .blocks = template.block_map,
        };

        try array.append(allocator, template_def);
    }
}

pub const TemplatePath = struct {
    prefix: []const u8,
    path: []const u8,
    present: bool,
};

const TemplateDef = struct {
    key: []const u8,
    name: []const u8,
    prefix: []const u8,
    content: []const u8,
    partial: bool,
    blocks: StringHashMap(ArrayList(Node.Block)),

    pub fn renderBlocks(template_def: TemplateDef, writer: *Writer) !void {
        var it = template_def.blocks.valueIterator();
        while (it.next()) |blocks| {
            for (blocks.items) |block| {
                try writer.print(
                    \\.{{ .name = "{[name]s}", .func = "{[func]s}" }},
                , .{
                    .name = block.name,
                    .func = block.func,
                });
            }
        }
    }
};
